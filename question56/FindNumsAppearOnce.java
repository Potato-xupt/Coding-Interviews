package question56;
/**
 * 数组中只出现一次的数字（可以拓展到只有一个数字出现一次，其他都出现偶数次的情况。
 * 题目描述
 * 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
 * num1,num2分别为长度为1的数组。传出参数
 * 将num1[0],num2[0]设置为返回结果
 * 
 * 解题思路：
 * 先考虑如果数组中只有一个数字出现一次，其他都出现两次的情况。
 * 因为一个数与自己做异或运算，得到的是0，因此对数组中所有的数字都做异或运算，得到的就是那个只出现一次的数字
 * 现在考虑有两个数字出现一次，其他都出现两次的情况。
 * 依旧对数组中所有的数字都做异或运算，得到的是数字m是两个只出现一次的数字相异或的结果
 * m的二进制数中的1就是那两个只出现一次的数字的二进制数不一样的位数
 * 因此从m的二进制数中取一个数字位1的下标i（我写的是从右往左第一个为1的下标），把整个数组分为两个数组，一个全是i处为1的数字，一个全是i处为0的数字
 * 然后这两个数组内部再分别做异或运算，就分别得到两个只出现一次的数字。
 * @author Potato
 *
 */
@SuppressWarnings("all")
public class FindNumsAppearOnce {
	
	public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
		/**
		 * 边界条件判断
		 */
        if(array == null || array.length < 2) {
        	return ;
        }
        /**
         * 	对数组中所有的数字做异或运算
         */
        int diff = array[0];
        for (int i = 1; i < array.length; i++) {
			diff ^= array[i];
		}
        /**
         * diff &= -diff 得到出 diff 最右侧不为 0 的位
         *	 也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。
         */
        diff &= -diff;
        /**
         * 	然后利用diff分两组异或运算
         */
        for(int num: array) {
        	if((num & diff) == 0) {
        		num1[0] ^= num;
        	}else {
        		num2[0] ^= num;
        	}
        }
    }

}
